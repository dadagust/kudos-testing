# Руководство по код-стайлу backend-приложения

Этот документ консолидирует фактические шаблоны оформления и архитектурные подходы, использованные во всех Python-модулях приложения. Руководство составлено на основе текущего кода и предназначено для того, чтобы новые изменения были визуально и структурно согласованы с существующей кодовой базой.

## Содержание
- [Общие принципы](#общие-принципы)
- [Структура модулей и организация файлов](#структура-модулей-и-организация-файлов)
- [Импорты](#импорты)
- [Модели Django](#модели-django)
- [Админ-интерфейс](#админ-интерфейс)
- [Фильтры](#фильтры)
- [Формы](#формы)
- [Сериализаторы DRF](#сериализаторы-drf)
- [Сервисный слой](#сервисный-слой)
- [Утилиты](#утилиты)
- [ViewSet-ы и REST-API](#viewset-ы-и-rest-api)
- [Классические CBV-представления](#классические-cbv-представления)
- [Маршрутизация](#маршрутизация)
- [Management-команды](#management-команды)
- [Конфигурация приложения](#конфигурация-приложения)
- [Миграции](#миграции)

## Общие принципы
- Используются аннотации типов везде, где это повышает читаемость (например, для параметров и возвращаемых значений сервисных методов). Если тип однозначен, аннотация может опускаться (например, у Django-полей).
- Строковые литералы преимущественно одинарные (`'`), двойные кавычки применяются лишь внутри форматирования или когда строка уже содержит одинарные кавычки.
- Логические блоки разделяются одной пустой строкой. Внутри классов оставляется пустая строка между полями/методами для визуального сгруппирования сущностей.
- Предпочитается явное использование вспомогательных функций и ранних выходов (guard clauses) для упрощения чтения кода, вместо глубокой вложенности условий.
- Паттерн `dict(...)` и генераторы списков применяются для нормализации структур данных и формирования ответов, что поддерживает единообразие обработки словарей и списков.

## Структура модулей и организация файлов
- Приложение разделено по ролям: `models`, `admin`, `forms`, `filters`, `serializers`, `services`, `utils`, `views`, `viewsets`, `urls`, а также подкаталоги `management` и `migrations`. Каждый файл отвечает за единственный слой ответственности, что снижает связность и упрощает навигацию.
- Web-интерфейс (Django CBV) и REST-API (DRF ViewSet) вынесены в отдельные файлы, чтобы разграничить зависимости от Django и DRF. URL-шаблоны объединяют оба типа представлений в одном `urls.py`, сохраняя последовательность маршрутов и группируя API-блоки комментариями.

## Импорты
- Порядок импортов: стандартная библиотека → сторонние пакеты → локальные модули. Между группами оставляется пустая строка.
- Для локальных модулей применяется относительный импорт (`from . import serializers`) или абсолютный импорт от корня приложения, если модуль используется в management-команде.
- При необходимости псевдонимов они выбираются по назначению (например, `forms as s2forms` для Select2-виджетов), чтобы подчеркнуть конкретное использование.

## Модели Django
- Каждая модель наследует общий базовый класс (`Common` или `Date`), обеспечивая поля аудита и единообразное поведение.
- Поля объявляются блочно: аргументы переносятся на новую строку с четырёхпробельным отступом и завершаются запятой, даже если параметр один. `verbose_name` располагается первым для полей, где задаётся несколько аргументов, что упрощает локализацию. Исключения (например, `max_length`) появляются только если параметр критичен для понимания типа поля.
- Логика Meta-классов следует шаблону: сначала `verbose_name`, затем `verbose_name_plural`, далее — `permissions`, `ordering`, `indexes`, `unique_together`. Структуры (кортежи, списки) записываются вертикально с завершающей запятой.
- Магический метод `__str__` присутствует у каждой модели и возвращает человекочитаемое представление, базируясь на ключевых полях или идентификаторах, объединённых через f-string.
- Сложные индексы и ограничения формулируются через `models.Index` внутри списка, что поддерживает читаемость при добавлении новых индексов.

## Админ-интерфейс
- Регистрация моделей производится через декоратор `@admin.register`, после чего объявляется класс, наследующий `admin.ModelAdmin`. Такой подход концентрирует настройку рядом с моделью и избавляет от явного вызова `admin.site.register` в конце файла.
- Кортежи и списки (`list_display`, `raw_id_fields`, `list_filter`, `search_fields`) записываются вертикально, даже если содержат единичный элемент. Это упрощает диффы и добавление новых пунктов.
- Для ForeignKey-полей админки используют `raw_id_fields`, что последовательно снижает нагрузку на админ-интерфейс и ускоряет поиск при большом объёме данных.

## Фильтры
- FilterSet описывается через атрибуты-классов, каждый фильтр разворачивается на отдельные строки с указанием `label`, `field_name`, `queryset` и `widget`. Виджеты Select2 получают атрибут `data-dropdown-parent`, чтобы корректно работать внутри модальных окон.
- Класс `Meta` содержит `model` и кортеж `fields`, перечисляющий допустимые фильтры в том же порядке, что и их объявление выше, поддерживая визуальное соответствие секций.

## Формы
- Формы наследуются от `forms.ModelForm` и дополняются явными полями, когда требуется изменить поведение формы относительно модели (например, задать `JSONField` с `HiddenInput`). Все аргументы полей вынесены на отдельные строки, а `label` всегда присутствует для пользовательских полей.
- Секция `Meta` повторяет порядок полей формы и переопределяет виджеты через словарь `widgets`, в котором каждое сопоставление находится на собственной строке.
- Метод `__init__` корректирует `initial`-значения, используя проверку наличия ключей, что гарантирует заполнение скрытых JSON-полей. Последовательные `if` разделены пустыми строками от остальной логики.
- Методы `clean_*` используют локальные списки и множества для нормализации данных, явно обрабатывая пустые значения. Результаты присваиваются обратно в `cleaned_data`, если требуются каскадные изменения (например, пересчёт `row_count`).

## Сериализаторы DRF
- Каждый сериализатор наследуется от `serializers.Serializer`, поля перечислены вертикально, сложные типы (`ListField`, `DictField`) раскрываются с описанием дочернего сериализатора. Такой стиль облегчает визуальное сравнение структуры ответа и контрактов API.
- Ответные сериализаторы (`GraphSnapshotMutationResponseSerializer`, `GraphCellUpdateResponseSerializer` и т.д.) расширяют базовые классы или объявляются заново, повторяя порядок полей ответа API. Это обеспечивает прямое соответствие сериализаторов и эндпоинтов.

## Сервисный слой
- Сервисы разделены на `GraphService` (мутирующая бизнес-логика) и `GraphExportService` (формирование XLSX). Методы `GraphService` объявлены как `@staticmethod`, что подчёркивает отсутствие состояния; для операций экспорта используется `@classmethod`, чтобы обращаться к константам класса напрямую.
- Для мутаций данных применяется схема: копирование существующих списков/словарей → модификация → сохранение модели с `update_fields`, минимизируя запись ненужных полей и гонки обновлений.
- Нормализация данных разнесена во вспомогательные методы `_ensure_len`, `_normalize_row_codes`, `_legacy_cp_codes`, что предотвращает дублирование логики в нескольких местах и облегчает тестирование отдельных шагов.
- Логирование изменений (`_log_static_change`, `_log_dynamic_change`) использует ранний выход при отсутствии фактических изменений и гарантирует, что значения приведены к строкам. Автор привязывается только если пользователь аутентифицирован, что согласуется с поведением комментариев и журнала изменений.
- `GraphExportService` определяет константы форматирования (цвета, стили) как атрибуты класса верхнего уровня, а построение XLSX выстраивается блоками: подготовка данных → сбор комментариев → генерация шапки → заполнение строк → постобработка ширин → финализация имени файла. Каждый блок отделяется пустыми строками и вспомогательными функциями внутри метода, чтобы держать контекст рядом с использованием.

## Утилиты
- Все функции утилит начинаются с подчёркивания, подчёркивая их предназначение «внутреннего» использования. Названия отражают конкретный шаг преобразования (`_normalized_schema`, `_cell_filter`, `_col_letter`).
- Валидационные функции (`_cell_filter`) используют строгие проверки входных данных с выбрасыванием `ValueError` и унифицированными сообщениями об ошибках. Это поведение используется ViewSet-ами напрямую, формируя ответы API с понятными текстами ошибок.
- Функции нормализации схемы дублируют логику (`_normalized_schema` и `_norm_schema`), сохраняя её и для REST, и для экспорта. Обе функции возвращают словарь фиксированного формата, независимо от исходных ключей (`items`/`periods`).

## ViewSet-ы и REST-API
- `GraphViewSet` наследуется от `viewsets.GenericViewSet` и хранит словарь `permission_classes_by_action`, который перекрывается в `get_permissions`. Такой подход обеспечивает гибкость по действиям без множества декораторов.
- Локальные методы `_require_perm` и `_require_dynamic_perm` инкапсулируют проверку прав. Они вызываются в начале публичных методов, формируя единый входной контракт и чёткие сообщения об ошибках. Guard clauses (`return Response(...)`) используются для раннего завершения при ошибках входных данных.
- Ответы API формируются через сериализаторы, причём данные подготавливаются в Python-структурах и только затем сериализуются. Это позволяет переиспользовать сериализаторы в разных действиях и поддерживает согласованность полей (`status`, `value`, `dynamic_schema` и т.д.).
- Методы, изменяющие состояние (`update_static_cell`, `schema`, `row`, `comment_add`, `snapshot_save`), повторяют паттерн: валидация входа → работа через сервис/утилиты → сериализация ответа. Для числовых параметров применяется принудительное преобразование к `int` с обработкой исключений, что делает API устойчивым к ошибкам клиента.
- Комментарии и журнал используют единый механизм приведения автора к строке (через `get_full_name`/`username`), оформленный inline-функциями; строки ответа содержат локализованные текстовые описания изменений, соответствуя фронтенд-ожиданиям.

## Классические CBV-представления
- Все HTML-представления основаны на наследовании от стандартных CBV (ListView, DetailView, CreateView, UpdateView) с `PermissionRequiredMixin`. Наследование оформлено многострочным списком базовых классов, каждый на отдельной строке, что облегчает добавление новых миксинов.
- Атрибуты класса (`model`, `permission_required`, `template_name`, `filterset_class`) идут блоком сразу после объявления, без пустых строк, подчёркивая их статичность. Методы (`form_valid`, `get_success_url`) отделяются пустой строкой и используют `reverse` для построения URL, зависящих от объекта.

## Маршрутизация
- `urlpatterns` оформлен как список вызовов `path`, каждый вызов многострочный: аргументы (`route`, `view`, `name`) располагаются на отдельных строках. Между логическими блоками маршрутов (страницы, API, экспорт, комментарии) вставлены комментарии, помогающие быстро ориентироваться в списке.
- ViewSet-ы подключаются через `as_view` с явным указанием словаря методов → действий, сохраняя компактность без использования `SimpleRouter`. Это подчёркивает контроль над конечными URL и соответствие существующему фронтенду.

## Management-команды
- Команда хранится в `applications.tables.management.commands` и наследуется от `BaseCommand`. Описание (`help`) задаётся строкой верхнего уровня, чтобы команда имела человекочитаемое описание в списке Django CLI.
- В методе `handle` используется поэтапная обработка: определение временных границ → ранний выход при отсутствии изменений → итерация по графикам → создание/обновление срезов. Каждая стадия отделена пустой строкой и сопровождается самодокументирующимися именами переменных (`changed_logs`, `graph_ids`, `last_snapshot`).
- Все обращения к моделям используют менеджеры на уровне моделей (`Graph.objects`, `GraphSnapshot.objects`) без прямых SQL, сохраняя ORM-совместимость и повторяя стиль сервиса экспорта/модификации графов.


## Миграции
- Миграции следуют стандартному Django-формату: комментарий о версии Django, объявление зависимостей, список операций. Даже в кастомных правках сохраняется структура с многострочными кортежами полей и словарями `options`, что упрощает чтение автогенерированного кода и поддержку последующих миграций.

Следование указанным правилам позволит поддерживать единый визуальный стиль и предсказуемость поведения кода во всём приложении.
