# Интеграция AmoCRM с сервисом аренды мебели

Этот документ описывает, как подключить AmoCRM к текущему приложению аренды, чтобы заявки, созданные клиентами на сайте или менеджерами в админке, автоматически превращались в сделки и контакты.

## Точки входа и сущности
- **Товары**: единицы номенклатуры с ценой, характеристиками и доступным остатком для аренды.【F:backend/applications/products/models.py†L199-L339】  
- **Клиенты**: персональные или корпоративные профили с менеджером-ответственным, контактами и компанией.【F:backend/applications/customers/models.py†L132-L199】  
- **Заказы**: содержат статусы, суммы, услуги (доставка/монтаж), адреса и строки заказа с выбранными товарами и режимами аренды.【F:backend/applications/orders/models.py†L90-L220】【F:backend/applications/orders/serializers.py†L9-L79】  
- **Публичные API**: каталог товаров доступен без авторизации, что подходит для клиентских форм аренды.【F:backend/applications/orders/public_views.py†L1-L37】  
- **Управление заказами**: `OrderViewSet` обслуживает создание и обновление заказов (используется менеджерами и любыми фронтами).【F:backend/applications/orders/views.py†L41-L182】

## Потоки синхронизации
1. **Создание заказа клиентом** (публичная форма → backend → `OrderViewSet.create`): после сохранения заказа отправляем payload в AmoCRM — контакт, компания (если B2B), сделка, товары в примечании/кастомных полях.
2. **Создание/редактирование менеджером** (личный кабинет/админка → `OrderViewSet`): тот же триггер с пометкой «источник — менеджер», чтобы различать лиды.
3. **Обновления статусов**: изменения полей `status`, `payment_status`, `logistics_state`, дат монтажа/отгрузки зеркалируются в стадии сделки или кастомные поля в AmoCRM. Обратные вебхуки AmoCRM (смена ответственного, стадии, оплаты) попадают в выделенный endpoint и обновляют локальный заказ.

## Предлагаемая архитектура
- **Клиент AmoCRM**: сервисный модуль (например, `applications/crm/amocrm.py`) с токен-обновлением, базовыми методами `upsert_contact`, `upsert_company`, `create_or_update_deal`, `attach_note`, `set_custom_fields`.
- **Маппинг данных**:
  - Контакт: `Customer.display_name/first_name/last_name`, `email`, `phone_normalized` → AmoCRM contact; `owner` → ответственный пользователь (по таблице соответствия).
  - Компания: `Company.name/inn/kpp/ogrn/phone/email/site` → AmoCRM company.
  - Сделка: общая сумма `total_amount`, услуги `services_total_amount`, доставка/монтаж, адреса, даты; строки заказа (`OrderItem`) сворачиваем в текстовое описание или в кастомное поле «Состав заказа».
  - Статусы заказа → этапы воронки (словари соответствия храним в настройках).
- **Триггеры**:
  - Сигналы post_save/post_delete на `Order` и `OrderItem` или сервисный слой в `OrderWriteSerializer.save` для вызова клиента AmoCRM после успешной транзакции.
  - Отдельная Celery-задача/фоновые воркеры на повторную отправку при сетевых ошибках.
- **Вебхуки AmoCRM → backend**:
  - Новый endpoint (например, `/api/crm/amocrm/webhook/`) принимает события смены статуса/ответственного/оплаты и обновляет `Order.status`, `Order.payment_status`, `warehouse_received_at` и `customer.owner` при необходимости.
  - Подпись/secret для валидации.
- **Логи и отслеживание**: таблица журнала синхронизации (order_id, amo_id, направление, payload, код ответа) для отладки и повторов.

## Настройка и конфигурация
- ENV-переменные: `AMOCRM_CLIENT_ID`, `AMOCRM_CLIENT_SECRET`, `AMOCRM_REDIRECT_URI`, `AMOCRM_REFRESH_TOKEN`, `AMOCRM_PIPELINE_ID`, `AMOCRM_STAGE_MAP_JSON` (маппинг статусов), `AMOCRM_RESPONSIBLE_MAP_JSON` (сопоставление менеджеров).
- Admin-настройка: в Django admin добавить singleton-модель «AmoCRM Settings» для хранения токена/маппингов без деплоя.
- Ограничения прав: использовать сервисную учётку AmoCRM; для клиентских форм (AllowAny) всю валидацию контактных данных оставлять на backend (нормализация телефона уже есть через `PhoneNormalizer`).

## Минимальный план внедрения
1. Реализовать модуль AmoCRM клиента и настройку токена.
2. Добавить слой маппинга и DTO для контакта/компании/сделки.
3. Подключить триггеры отправки в AmoCRM после создания/обновления заказов и их позиций.
4. Сделать resilient-очередь (Celery/Redis) для ретраев.
5. Открыть и защитить webhook endpoint, связать события с локальными статусами.
6. Описать в README шаги настройки OAuth и проверку соединения.
